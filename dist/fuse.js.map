{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 99092c1f3cee8e7c3d8b","webpack:///./src/helpers/is_array.js","webpack:///./src/bitap/index.js","webpack:///./src/helpers/deep_value.js","webpack:///./src/stopWordsMap.js","webpack:///./src/bitap/bitap_matched_indices.js","webpack:///./src/bitap/bitap_pattern_alphabet.js","webpack:///./src/bitap/bitap_regex_search.js","webpack:///./src/bitap/bitap_score.js","webpack:///./src/bitap/bitap_search.js","webpack:///./src/index.js"],"names":["module","exports","Array","isArray","Object","prototype","toString","call","obj","bitapRegexSearch","require","bitapSearch","patternAlphabet","Bitap","pattern","location","distance","threshold","maxPatternLength","isCaseSensitive","tokenSeparator","findAllMatches","minMatchCharLength","options","toLowerCase","length","text","isMatch","score","matchedIndices","deepValue","path","list","push","dotIndex","indexOf","firstSegment","remaining","slice","value","undefined","i","len","a","able","about","across","after","all","almost","also","am","among","an","and","any","are","as","at","be","because","been","but","by","can","cannot","could","dear","did","does","either","ever","every","from","got","had","has","have","he","her","hers","him","his","how","however","into","is","it","its","just","least","let","like","likely","may","me","might","most","must","my","neither","no","nor","not","of","off","often","on","only","or","other","our","own","rather","said","say","says","she","should","since","so","some","than","that","the","their","them","then","there","these","they","tis","to","too","twas","us","wants","was","we","were","what","when","where","which","who","whom","why","will","would","yet","you","your","matchmask","start","end","match","mask","charAt","SPECIAL_CHARS_REGEX","regex","RegExp","replace","matches","matchesLen","errors","currentLocation","expectedLocation","accuracy","proximity","Math","abs","bitapScore","textLen","currentThreshold","bestLocation","patternLen","matchMask","min","lastIndexOf","lastBitArr","finalScore","binMax","binMin","binMid","floor","max","finish","bitArr","j","charMatch","stopWordsMap","Fuse","caseSensitive","id","keys","shouldSort","getFn","sortFn","b","tokenize","matchAllTokens","stopWords","includeMatches","includeScore","verbose","setCollection","_log","_prepareSearchers","tokenSearchers","fullSearcher","_search","weights","results","_computeScore","_sort","_format","tokens","split","filter","token","resultMap","_analyze","key","record","index","item","keysLen","name","weight","Error","arrayIndex","exists","averageScore","numTextMatches","mainSearchResult","search","words","scores","tokenSearcher","hasMatchInText","word","tokenSearchResult","scoresLen","checkTextMatches","existingResult","output","scoreLen","currScore","bestScore","nScore","sort","finalOutput","JSON","stringify","transformers","result","data","indices","hasOwnProperty","log","arguments"],"mappings":"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","file":"fuse.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Fuse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fuse\"] = factory();\n\telse\n\t\troot[\"Fuse\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 99092c1f3cee8e7c3d8b","module.exports = obj => !Array.isArray ? Object.prototype.toString.call(obj) === '[object Array]' : Array.isArray(obj)\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/is_array.js","const bitapRegexSearch = require('./bitap_regex_search')\nconst bitapSearch = require('./bitap_search')\nconst patternAlphabet = require('./bitap_pattern_alphabet')\n\nclass Bitap {\n  constructor (pattern, {\n    // Approximately where in the text is the pattern expected to be found?\n    location = 0,\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance = 100,\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold = 0.6,\n    // Machine word size\n    maxPatternLength = 32,\n    // Indicates whether comparisons should be case sensitive.\n    isCaseSensitive = false,\n    // Regex used to separate words when searching. Only applicable when `tokenize` is `true`.\n    tokenSeparator = / +/g,\n    // When true, the algorithm continues searching to the end of the input even if a perfect\n    // match is found before the end of the same input.\n    findAllMatches = false,\n    // Minimum number of characters that must be matched before a result is considered a match\n    minMatchCharLength = 1\n  }) {\n    this.options = {\n      location,\n      distance,\n      threshold,\n      maxPatternLength,\n      isCaseSensitive,\n      tokenSeparator,\n      findAllMatches,\n      minMatchCharLength\n    }\n\n    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase()\n\n    if (this.pattern.length <= maxPatternLength) {\n      this.patternAlphabet = patternAlphabet(this.pattern)\n    }\n  }\n\n  search (text) {\n    if (!this.options.isCaseSensitive) {\n      text = text.toLowerCase()\n    }\n\n    // Exact match\n    if (this.pattern === text) {\n      return {\n        isMatch: true,\n        score: 0,\n        matchedIndices: [[0, text.length - 1]]\n      }\n    }\n\n    // When pattern length is greater than the machine word length, just do a a regex comparison\n    const { maxPatternLength, tokenSeparator } = this.options\n    if (this.pattern.length > maxPatternLength) {\n      return bitapRegexSearch(text, this.pattern, tokenSeparator)\n    }\n\n    // Otherwise, use Bitap algorithm\n    const { location, distance, threshold, findAllMatches, minMatchCharLength } = this.options\n    return bitapSearch(text, this.pattern, this.patternAlphabet, {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength\n    })\n  }\n}\n\n// let x = new Bitap(\"od mn war\", {})\n// let result = x.search(\"Old Man's War\")\n// console.log(result)\n\nmodule.exports = Bitap\n\n\n\n// WEBPACK FOOTER //\n// ./src/bitap/index.js","const isArray = require('./is_array')\n\nconst deepValue = (obj, path, list) => {\n  if (!path) {\n    // If there's no path left, we've gotten to the object we care about.\n    list.push(obj)\n  } else {\n    const dotIndex = path.indexOf('.')\n    let firstSegment = path\n    let remaining = null\n\n    if (dotIndex !== -1) {\n      firstSegment = path.slice(0, dotIndex)\n      remaining = path.slice(dotIndex + 1)\n    }\n\n    const value = obj[firstSegment]\n\n    if (value !== null && value !== undefined) {\n      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n        list.push(value.toString())\n      } else if (isArray(value)) {\n        // Search each item in the array.\n        for (let i = 0, len = value.length; i < len; i += 1) {\n          deepValue(value[i], remaining, list)\n        }\n      } else if (remaining) {\n        // An object. Recurse further.\n        deepValue(value, remaining, list)\n      }\n    }\n  }\n\n  return list\n}\n\nmodule.exports = (obj, path) => {\n  return deepValue(obj, path, [])\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/deep_value.js","module.exports = {\n  a: true,\n  able: true,\n  about: true,\n  across: true,\n  after: true,\n  all: true,\n  almost: true,\n  also: true,\n  am: true,\n  among: true,\n  an: true,\n  and: true,\n  any: true,\n  are: true,\n  as: true,\n  at: true,\n  be: true,\n  because: true,\n  been: true,\n  but: true,\n  by: true,\n  can: true,\n  cannot: true,\n  could: true,\n  dear: true,\n  did: true,\n  'do': true,\n  does: true,\n  either: true,\n  'else': true,\n  ever: true,\n  every: true,\n  'for': true,\n  from: true,\n  'get': true,\n  got: true,\n  had: true,\n  has: true,\n  have: true,\n  he: true,\n  her: true,\n  hers: true,\n  him: true,\n  his: true,\n  how: true,\n  however: true,\n  i: true,\n  'if': true,\n  'in': true,\n  into: true,\n  is: true,\n  it: true,\n  its: true,\n  just: true,\n  least: true,\n  let: true,\n  like: true,\n  likely: true,\n  may: true,\n  me: true,\n  might: true,\n  most: true,\n  must: true,\n  my: true,\n  neither: true,\n  no: true,\n  nor: true,\n  not: true,\n  of: true,\n  off: true,\n  often: true,\n  on: true,\n  only: true,\n  or: true,\n  other: true,\n  our: true,\n  own: true,\n  rather: true,\n  said: true,\n  say: true,\n  says: true,\n  she: true,\n  should: true,\n  since: true,\n  so: true,\n  some: true,\n  than: true,\n  that: true,\n  the: true,\n  their: true,\n  them: true,\n  then: true,\n  there: true,\n  these: true,\n  they: true,\n  'this': true,\n  tis: true,\n  to: true,\n  too: true,\n  twas: true,\n  us: true,\n  wants: true,\n  was: true,\n  we: true,\n  were: true,\n  what: true,\n  when: true,\n  where: true,\n  which: true,\n  'while': true,\n  who: true,\n  whom: true,\n  why: true,\n  will: true,\n  'with': true,\n  would: true,\n  yet: true,\n  you: true,\n  your: true\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/stopWordsMap.js","module.exports = (matchmask = [], minMatchCharLength = 1) => {\n  let matchedIndices = []\n  let start = -1\n  let end = -1\n  let i = 0\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i]\n    if (match && start === -1) {\n      start = i\n    } else if (!match && start !== -1) {\n      end = i - 1\n      if ((end - start) + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end])\n      }\n      start = -1\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && (i - start) >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1])\n  }\n\n  return matchedIndices\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/bitap/bitap_matched_indices.js","module.exports = (pattern) => {\n  let mask = {}\n  let len = pattern.length\n\n  for (let i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0\n  }\n\n  for (let i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] |= 1 << (len - i - 1)\n  }\n\n  return mask\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/bitap/bitap_pattern_alphabet.js","const SPECIAL_CHARS_REGEX = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g\n\nmodule.exports = (text, pattern, tokenSeparator = / +/g) => {\n  let regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\\\$&').replace(tokenSeparator, '|'))\n  let matches = text.match(regex)\n  let isMatch = !!matches\n  let matchedIndices = []\n\n  if (isMatch) {\n    for (let i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {\n      let match = matches[i]\n      matchedIndices.push([text.indexOf(match), match.length - 1])\n    }\n  }\n\n  return {\n    // TODO: revisit this score\n    score: isMatch ? 0.5 : 1,\n    isMatch,\n    matchedIndices\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/bitap/bitap_regex_search.js","module.exports = (pattern, { errors = 0, currentLocation = 0, expectedLocation = 0, distance = 100 }) => {\n  const accuracy = errors / pattern.length\n  const proximity = Math.abs(expectedLocation - currentLocation)\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + (proximity / distance)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/bitap/bitap_score.js","const bitapScore = require('./bitap_score')\nconst matchedIndices = require('./bitap_matched_indices')\n\nmodule.exports = (text, pattern, patternAlphabet, { location = 0, distance = 100, threshold = 0.6, findAllMatches = false, minMatchCharLength = 1 }) => {\n  const expectedLocation = location\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = text.indexOf(pattern, expectedLocation)\n\n  const patternLen = pattern.length\n\n  // a mask of the matches\n  const matchMask = []\n  for (let i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0\n  }\n\n  if (bestLocation !== -1) {\n    let score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation,\n      distance\n    })\n    currentThreshold = Math.min(score, currentThreshold)\n\n    // What about in the other direction? (speed up)\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen)\n\n    if (bestLocation !== -1) {\n      let score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation,\n        distance\n      })\n      currentThreshold = Math.min(score, currentThreshold)\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1\n\n  let lastBitArr = []\n  let finalScore = 1\n  let binMax = patternLen + textLen\n\n  const mask = 1 << (patternLen - 1)\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0\n    let binMid = binMax\n\n    while (binMin < binMid) {\n      const score = bitapScore(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance\n      })\n\n      if (score <= currentThreshold) {\n        binMin = binMid\n      } else {\n        binMax = binMid\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin)\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid\n\n    let start = Math.max(1, expectedLocation - binMid + 1)\n    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2)\n\n    bitArr[finish + 1] = (1 << i) - 1\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1\n      let charMatch = patternAlphabet[text.charAt(currentLocation)]\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch\n\n      // Subsequent passes: fuzzy match\n      if (i !== 0) {\n        bitArr[j] |= (((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1) | lastBitArr[j + 1]\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance\n        })\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore\n          bestLocation = currentLocation\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation)\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = bitapScore(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance\n    })\n\n    // console.log('score', score, finalScore)\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr\n  }\n\n  // console.log('FINAL SCORE', finalScore)\n\n  // Count exact matches (those with a score of 0) to be \"almost\" exact\n  return {\n    isMatch: bestLocation >= 0,\n    score: finalScore === 0 ? 0.001 : finalScore,\n    matchedIndices: matchedIndices(matchMask, minMatchCharLength)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/bitap/bitap_search.js","const Bitap = require('./bitap')\nconst deepValue = require('./helpers/deep_value')\nconst isArray = require('./helpers/is_array')\nconst stopWordsMap = require('./stopWordsMap')\n\nclass Fuse {\n  constructor (list, {\n    // Approximately where in the text is the pattern expected to be found?\n    location = 0,\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance = 100,\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold = 0.6,\n    // Machine word size\n    maxPatternLength = 32,\n    // Indicates whether comparisons should be case sensitive.\n    caseSensitive = false,\n    // Regex used to separate words when searching. Only applicable when `tokenize` is `true`.\n    tokenSeparator = / +/g,\n    // When true, the algorithm continues searching to the end of the input even if a perfect\n    // match is found before the end of the same input.\n    findAllMatches = false,\n    // Minimum number of characters that must be matched before a result is considered a match\n    minMatchCharLength = 1,\n    // The name of the identifier property. If specified, the returned result will be a list\n    // of the items' dentifiers, otherwise it will be a list of the items.\n    id = null,\n    // List of properties that will be searched. This also supports nested properties.\n    keys = [],\n    // Whether to sort the result list, by score\n    shouldSort = true,\n    // The get function to use when fetching an object's properties.\n    // The default will search nested paths *ie foo.bar.baz*\n    getFn = deepValue,\n    // Default sort function\n    sortFn = (a, b) => (a.score - b.score),\n    // When true, the search algorithm will search individual words **and** the full string,\n    // computing the final score as a function of both. Note that when `tokenize` is `true`,\n    // the `threshold`, `distance`, and `location` are inconsequential for individual tokens.\n    tokenize = false,\n    // When true, the result set will only include records that match all tokens. Will only work\n    // if `tokenize` is also true.\n    matchAllTokens = false,\n    stopWords = stopWordsMap,\n\n    includeMatches = false,\n    includeScore = false,\n\n    // Will print to the console. Useful for debugging.\n    verbose = false\n  }) {\n    this.options = {\n      location,\n      distance,\n      threshold,\n      maxPatternLength,\n      isCaseSensitive: caseSensitive,\n      tokenSeparator,\n      findAllMatches,\n      minMatchCharLength,\n      id,\n      keys,\n      includeMatches,\n      includeScore,\n      shouldSort,\n      getFn,\n      sortFn,\n      verbose,\n      tokenize,\n      matchAllTokens\n    }\n\n    this.setCollection(list)\n  }\n\n  setCollection (list) {\n    this.list = list\n    return list\n  }\n\n  search (pattern) {\n    this._log(`---------\\nSearch pattern: \"${pattern}\"`)\n\n    const {\n      tokenSearchers,\n      fullSearcher\n    } = this._prepareSearchers(pattern)\n\n    let { weights, results } = this._search(tokenSearchers, fullSearcher)\n\n    this._computeScore(weights, results)\n\n    if (this.options.shouldSort) {\n      this._sort(results)\n    }\n\n    return this._format(results)\n  }\n\n  _prepareSearchers (pattern = '') {\n    const tokenSearchers = []\n\n    if (this.options.tokenize) {\n      // Tokenize on the separator\n      const tokens = pattern.split(this.options.tokenSeparator)\n        .filter(token => !this.options.stopWords[token])\n      for (let i = 0, len = tokens.length; i < len; i += 1) {\n        tokenSearchers.push(new Bitap(tokens[i], this.options))\n      }\n    }\n\n    let fullSearcher = new Bitap(pattern, this.options)\n\n    return { tokenSearchers, fullSearcher }\n  }\n\n  _search (tokenSearchers = [], fullSearcher) {\n    const list = this.list\n    const resultMap = {}\n    const results = []\n\n    // Check the first item in the list, if it's a string, then we assume\n    // that every item in the list is also a string, and thus it's a flattened array.\n    if (typeof list[0] === 'string') {\n      // Iterate over every item\n      for (let i = 0, len = list.length; i < len; i += 1) {\n        this._analyze({\n          key: '',\n          value: list[i],\n          record: i,\n          index: i\n        }, {\n          resultMap,\n          results,\n          tokenSearchers,\n          fullSearcher\n        })\n      }\n\n      return { weights: null, results }\n    }\n\n    // Otherwise, the first item is an Object (hopefully), and thus the searching\n    // is done on the values of the keys of each item.\n    const weights = {}\n    for (let i = 0, len = list.length; i < len; i += 1) {\n      let item = list[i]\n      // Iterate over every key\n      for (let j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {\n        let key = this.options.keys[j]\n        if (typeof key !== 'string') {\n          weights[key.name] = {\n            weight: (1 - key.weight) || 1\n          }\n          if (key.weight <= 0 || key.weight > 1) {\n            throw new Error('Key weight has to be > 0 and <= 1')\n          }\n          key = key.name\n        } else {\n          weights[key] = {\n            weight: 1\n          }\n        }\n\n        this._analyze({\n          key,\n          value: this.options.getFn(item, key),\n          record: item,\n          index: i\n        }, {\n          resultMap,\n          results,\n          tokenSearchers,\n          fullSearcher\n        })\n      }\n    }\n\n    return { weights, results }\n  }\n\n  _analyze ({ key, arrayIndex = -1, value, record, index }, { tokenSearchers = [], fullSearcher = [], resultMap = {}, results = [] }) {\n    // Check if the texvaluet can be searched\n    if (value === undefined || value === null) {\n      return\n    }\n\n    let exists = false\n    let averageScore = -1\n    let numTextMatches = 0\n\n    if (typeof value === 'string') {\n      this._log(`\\nKey: ${key === '' ? '-' : key}`)\n\n      let mainSearchResult = fullSearcher.search(value)\n      this._log(`Full text: \"${value}\", score: ${mainSearchResult.score}`)\n\n      if (this.options.tokenize) {\n        let words = value.split(this.options.tokenSeparator)\n          .filter(token => !this.options.stopWords[token])\n        let scores = []\n\n        for (let i = 0; i < tokenSearchers.length; i += 1) {\n          let tokenSearcher = tokenSearchers[i]\n\n          this._log(`\\nPattern: \"${tokenSearcher.pattern}\"`)\n\n          // let tokenScores = []\n          let hasMatchInText = false\n\n          for (let j = 0; j < words.length; j += 1) {\n            let word = words[j]\n            let tokenSearchResult = tokenSearcher.search(word)\n            let obj = {}\n            if (tokenSearchResult.isMatch) {\n              obj[word] = tokenSearchResult.score\n              exists = true\n              hasMatchInText = true\n              scores.push(tokenSearchResult.score)\n            } else {\n              obj[word] = 1\n              if (!this.options.matchAllTokens) {\n                scores.push(1)\n              }\n            }\n            this._log(`Token: \"${word}\", score: ${obj[word]}`)\n            // tokenScores.push(obj)\n          }\n\n          if (hasMatchInText) {\n            numTextMatches += 1\n          }\n        }\n\n        averageScore = scores[0]\n        let scoresLen = scores.length\n        for (let i = 1; i < scoresLen; i += 1) {\n          averageScore += scores[i]\n        }\n        averageScore = averageScore / scoresLen\n\n        this._log('Token score average:', averageScore)\n      }\n\n      let finalScore = mainSearchResult.score\n      if (averageScore > -1) {\n        finalScore = (finalScore + averageScore) / 2\n      }\n\n      this._log('Score average:', finalScore)\n\n      let checkTextMatches = (this.options.tokenize && this.options.matchAllTokens) ? numTextMatches >= tokenSearchers.length : true\n\n      this._log(`\\nCheck Matches: ${checkTextMatches}`)\n\n      // If a match is found, add the item to <rawResults>, including its score\n      if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n        // Check if the item already exists in our results\n        let existingResult = resultMap[index]\n        if (existingResult) {\n          // Use the lowest score\n          // existingResult.score, bitapResult.score\n          existingResult.output.push({\n            key,\n            arrayIndex,\n            value,\n            score: finalScore,\n            matchedIndices: mainSearchResult.matchedIndices\n          })\n        } else {\n          // Add it to the raw result list\n          resultMap[index] = {\n            item: record,\n            output: [{\n              key,\n              arrayIndex,\n              value,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            }]\n          }\n\n          results.push(resultMap[index])\n        }\n      }\n    } else if (isArray(value)) {\n      for (let i = 0, len = value.length; i < len; i += 1) {\n        this._analyze({\n          key,\n          arrayIndex: i,\n          value: value[i],\n          record,\n          index\n        }, {\n          resultMap,\n          results,\n          tokenSearchers,\n          fullSearcher\n        })\n      }\n    }\n  }\n\n  _computeScore (weights, results) {\n    this._log('\\n\\nComputing score:\\n')\n\n    for (let i = 0, len = results.length; i < len; i += 1) {\n      const output = results[i].output\n      const scoreLen = output.length\n\n      let currScore = 1\n      let bestScore = 1\n\n      for (let j = 0; j < scoreLen; j += 1) {\n        let weight = weights ? weights[output[j].key].weight : 1\n        let score = weight === 1 ? output[j].score : (output[j].score || 0.001)\n        let nScore = score * weight\n\n        if (weight !== 1) {\n          bestScore = Math.min(bestScore, nScore)\n        } else {\n          output[j].nScore = nScore\n          currScore *= nScore\n        }\n      }\n\n      results[i].score = bestScore === 1 ? currScore : bestScore\n\n      this._log(results[i])\n    }\n  }\n\n  _sort (results) {\n    this._log('\\n\\nSorting....')\n    results.sort(this.options.sortFn)\n  }\n\n  _format (results) {\n    const finalOutput = []\n\n    if (this.options.verbose) {\n      this._log('\\n\\nOutput:\\n\\n', JSON.stringify(results))\n    }\n\n    let transformers = []\n\n    if (this.options.includeMatches) {\n      transformers.push((result, data) => {\n        const output = result.output\n        data.matches = []\n\n        for (let i = 0, len = output.length; i < len; i += 1) {\n          let item = output[i]\n\n          if (item.matchedIndices.length === 0) {\n            continue\n          }\n\n          let obj = {\n            indices: item.matchedIndices,\n            value: item.value\n          }\n          if (item.key) {\n            obj.key = item.key\n          }\n          if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {\n            obj.arrayIndex = item.arrayIndex\n          }\n          data.matches.push(obj)\n        }\n      })\n    }\n\n    if (this.options.includeScore) {\n      transformers.push((result, data) => {\n        data.score = result.score\n      })\n    }\n\n    for (let i = 0, len = results.length; i < len; i += 1) {\n      const result = results[i]\n\n      if (this.options.id) {\n        result.item = this.options.getFn(result.item, this.options.id)[0]\n      }\n\n      if (!transformers.length) {\n        finalOutput.push(result.item)\n        continue\n      }\n\n      const data = {\n        item: result.item\n      }\n\n      for (let j = 0, len = transformers.length; j < len; j += 1) {\n        transformers[j](result, data)\n      }\n\n      finalOutput.push(data)\n    }\n\n    return finalOutput\n  }\n\n  _log () {\n    if (this.options.verbose) {\n      console.log(...arguments)\n    }\n  }\n}\n\nmodule.exports = Fuse\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}